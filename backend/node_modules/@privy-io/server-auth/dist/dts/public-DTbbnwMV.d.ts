import * as _solana_web3_js from '@solana/web3.js';
import { Transaction, VersionedTransaction } from '@solana/web3.js';
import * as redaxios from 'redaxios';
import redaxios__default from 'redaxios';
import { ChainType, CustomMetadataType, SmartWalletType, Prettify, PolicyActionType, WalletImportSupportedChains } from '@privy-io/public-api';

type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
type LinkedAccountType = 'wallet' | 'smart_wallet' | 'email' | 'phone' | 'google_oauth' | 'twitter_oauth' | 'discord_oauth' | 'github_oauth' | 'apple_oauth' | 'linkedin_oauth' | 'tiktok_oauth' | 'spotify_oauth' | 'instagram_oauth' | 'custom_auth' | 'farcaster' | 'telegram' | 'cross_app' | 'passkey';
/** @ignore */
interface LinkMetadata {
    /** Account type, most commonly useful when filtering through linkedAccounts */
    type: LinkedAccountType;
    /**
     * @deprecated use `firstVerifiedAt` instead.
     * Datetime when this account was linked to the user or created. */
    verifiedAt: Date;
    /** Datetime when this account was linked to the user. */
    firstVerifiedAt: Date | null;
    /** Datetime when this account was most recently used as a login/link method by the user. */
    latestVerifiedAt: Date | null;
}
/**
 * Object representation of a user's wallet.
 */
interface Wallet {
    /** The server wallet ID of the wallet. Null if the wallet is not delegated and not on the unified wallets stack. Only applies to embedded wallets (`walletClientType === 'privy'`). */
    id?: string | null;
    /** The wallet address. */
    address: string;
    /**
     * Chain type of the wallet address.
     *
     * e.g. `ethereum`, `solana`
     */
    chainType: ChainType;
    /**
     * @deprecated Use `chainType` instead.
     *
     * CAIP-2 formatted chain ID during the most recent verification.
     *
     * e.g. eip155:1, eip155:5, eip155:137, etc.
     */
    chainId?: string;
    /**
     * @deprecated Use `walletClientType` instead.
     */
    walletType?: string;
    /**
     * The wallet client used for this wallet during the most recent verification.
     *
     * If the value is `privy`, then this is a privy embedded wallet.
     *
     * Other values include but are not limited to `metamask`, `rainbow`, `coinbase_wallet`, etc.
     */
    walletClientType?: string;
    /**
     * The connector type used for this wallet during the most recent verification.
     *
     * This includes but is not limited to `injected`, `wallet_connect`, `coinbase_wallet`, `embedded`.
     */
    connectorType?: string;
    /**
     * The index of this wallet for an HD wallet, if the wallet is an embedded wallet.
     */
    hdWalletIndex?: number;
    /**
     * Whether or not this wallet was imported by the user. Will be undefined if the wallet is not
     * an embedded wallet.
     */
    imported?: boolean;
    /**
     * Whether or not this wallet was delegated by the user. Will be undefined if the wallet is not
     * an embedded wallet.
     */
    delegated?: boolean;
}
/** Object representation of a user's email. */
interface Email {
    /** The email address. */
    address: string;
}
/**
 * Object representation of a smart wallet.
 */
interface SmartWallet {
    /** The wallet address. */
    address: string;
    /** The provider of the smart wallet. */
    smartWalletType: SmartWalletType;
    /** The version of the smart wallet, if applicable. */
    smartWalletVersion?: string;
}
/** Object representation of a user's phone number. */
interface Phone {
    /** The phone number. */
    number: string;
}
/** Object representation of a user's Google account. */
interface Google {
    /** The `sub` claim from the Google-issued JWT for this account. */
    subject: string;
    /** The email associated with the Google account. */
    email: string;
    /** The name associated with the Google account. */
    name: string | null;
}
/** Object representation of a user's Twitter account. */
interface Twitter {
    /** The `sub` claim from the Twitter-issued JWT for this account. */
    subject: string;
    /** The username associated with the Twitter account. */
    username: string | null;
    /** The name associated with the Twitter account. */
    name: string | null;
    /** The profile picture URL associated with the Twitter account. */
    profilePictureUrl?: string | null;
}
/** Object representation of a user's Discord account. */
interface Discord {
    /** The `sub` claim from the Discord-issued JWT for this account. */
    subject: string;
    /** The username associated with the Discord account.  */
    username: string | null;
    /** The email associated with the Discord account. */
    email: string | null;
}
/** Object representation of a user's Github account. */
interface Github {
    /** The `sub` claim from the Github-issued JWT for this account. */
    subject: string;
    /** The username associated with the Github account.  */
    username: string | null;
    /** The email associated with the Github account. */
    email: string | null;
    /** The name associated with the Github account. */
    name: string | null;
}
/** Object representation of a user's Apple account. */
interface Apple {
    /** The `sub` claim from the Apple-issued JWT for this account. */
    subject: string;
    /** The email associated with the Apple account. */
    email: string;
}
/** Object representation of a user's LinkedIn account. */
interface LinkedIn {
    /** The `sub` claim from the LinkedIn-issued JWT for this account. */
    subject: string;
    /** The email associated with the LinkedIn account. */
    email: string;
    /** The name associated with the LinkedIn account. */
    name: string;
    /** The vanity name associated with the LinkedIn account. */
    vanityName?: string;
}
/** Object representation of a user's Tiktok account. */
interface Tiktok {
    /** The `sub` claim from the Tiktok-issued JWT for this account. */
    subject: string;
    /** The username associated with the Tiktok account. */
    username?: string;
    /** The name associated with the Tiktok account. */
    name: string;
}
interface Spotify {
    /** The `sub` claim from the Spotify-issued JWT for this account. */
    subject: string;
    /** The email associated with the Spotify account. */
    email?: string;
    /** The name associated with the Spotify account. */
    name?: string;
}
interface Instagram {
    /** The `sub` claim from the Instagram-issued JWT for this account. */
    subject: string;
    /** The username associated with the Instagram account. */
    username: string;
}
interface Telegram {
    telegramUserId: string;
    firstName?: string;
    lastName?: string;
    username?: string;
    photoUrl?: string;
}
interface Farcaster {
    fid: number;
    ownerAddress: string;
    username?: string;
    displayName?: string;
    bio?: string;
    pfp?: string;
    url?: string;
}
/** Metadata about the provider app for a cross-app account */
interface ProviderAppMetadata {
    /** Privy app ID for the provider app. */
    id: string;
    /** Name for the provider app. */
    name?: string;
    /** Logo URL for the provider app. */
    logoUrl?: string;
}
interface CrossAppEmbeddedWallet {
    address: string;
}
interface CrossAppSmartWallet {
    address: string;
}
interface CrossAppAccount {
    /** The user's embedded wallet address(es) from the provider app */
    embeddedWallets: CrossAppEmbeddedWallet[];
    smartWallets: CrossAppSmartWallet[];
    providerApp: ProviderAppMetadata;
    subject: string;
}
interface PasskeyAccount {
    credentialId: string;
}
/** Object representation of a user's Custom JWT account. */
interface CustomJwt {
    /** The `sub` claim (or specified attribute in console configuration) from the Custom JWT for this account. */
    customUserId: string;
}
/** Object representation of a user's email, with additional metadata for advanced use cases. */
interface EmailWithMetadata extends LinkMetadata, Email {
    /** Denotes that this is an email account. */
    type: 'email';
}
/** Object representation of a user's phone number, with additional metadata for advanced use cases. */
interface PhoneWithMetadata extends LinkMetadata, Phone {
    /** Denotes that this is a phone account. */
    type: 'phone';
}
/** Object representation of a user's wallet, with additional metadata for advanced use cases. */
interface WalletWithMetadata extends LinkMetadata, Wallet {
    /** Denotes that this is a wallet account. */
    type: 'wallet';
}
interface SmartWalletWithMetadata extends LinkMetadata, SmartWallet {
    /** Denotes that this is a smart wallet account. */
    type: 'smart_wallet';
}
/** Object representation of a user's Google Account, with additional metadata for advanced use cases. */
interface GoogleOAuthWithMetadata extends LinkMetadata, Google {
    /** Denotes that this is a Google account. */
    type: 'google_oauth';
}
/** Object representation of a user's Twitter Account, with additional metadata for advanced use cases. */
interface TwitterOAuthWithMetadata extends LinkMetadata, Twitter {
    /** Denotes that this is a Twitter account. */
    type: 'twitter_oauth';
}
/** Object representation of a user's Discord Account, with additional metadata for advanced use cases. */
interface DiscordOAuthWithMetadata extends LinkMetadata, Discord {
    /** Denotes that this is a Discord account. */
    type: 'discord_oauth';
}
/** Object representation of a user's Github Account, with additional metadata for advanced use cases. */
interface GithubOAuthWithMetadata extends LinkMetadata, Github {
    /** Denotes that this is a Github account. */
    type: 'github_oauth';
}
/** Object representation of a user's Apple Account, with additional metadata for advanced use cases. */
interface AppleOAuthWithMetadata extends LinkMetadata, Apple {
    /** Denotes that this is a Apple account. */
    type: 'apple_oauth';
}
/** Object representation of a user's LinkedIn Account, with additional metadata for advanced use cases. */
interface LinkedInOAuthWithMetadata extends LinkMetadata, LinkedIn {
    /** Denotes that this is a LinkedIn account. */
    type: 'linkedin_oauth';
}
/** Object representation of a user's Tiktok Account, with additional metadata for advanced use cases. */
interface TiktokOAuthWithMetadata extends LinkMetadata, Tiktok {
    /** Denotes that this is a Tiktok account. */
    type: 'tiktok_oauth';
}
/** Object representation of a user's Spotify Account, with additional metadata for advanced use cases. */
interface SpotifyOAuthWithMetadata extends LinkMetadata, Spotify {
    /** Denotes that this is a Spotify account. */
    type: 'spotify_oauth';
}
/** Object representation of a user's Instagram Account, with additional metadata for advanced use cases. */
interface InstagramOAuthWithMetadata extends LinkMetadata, Instagram {
    /** Denotes that this is an Instagram account. */
    type: 'instagram_oauth';
}
/** Object representation of a user's Custom JWT Account, with additional metadata for advanced use cases. */
interface CustomJwtWithMetadata extends LinkMetadata, CustomJwt {
    /** Denotes that this is a Custom JWT account. */
    type: 'custom_auth';
}
interface FarcasterWithMetadata extends LinkMetadata, Farcaster {
    /** Denotes that this is a Farcaster account. */
    type: 'farcaster';
}
interface TelegramWithMetadata extends LinkMetadata, Telegram {
    /** Denotes that this is a Telegram account. */
    type: 'telegram';
}
/** Object representation of a user's cross-app account, with additional metadata for advanced use cases. */
interface CrossAppAccountWithMetadata extends LinkMetadata, CrossAppAccount {
    /** Denotes that this is a cross-app account */
    type: 'cross_app';
}
interface PasskeyAccountWithMetadata extends LinkMetadata, PasskeyAccount {
    /** Denotes that this is a passkey account */
    type: 'passkey';
}
/** Generic object representation of a linked account */
type LinkedAccountWithMetadata = WalletWithMetadata | SmartWalletWithMetadata | EmailWithMetadata | PhoneWithMetadata | GoogleOAuthWithMetadata | TwitterOAuthWithMetadata | DiscordOAuthWithMetadata | GithubOAuthWithMetadata | AppleOAuthWithMetadata | LinkedInOAuthWithMetadata | TiktokOAuthWithMetadata | SpotifyOAuthWithMetadata | InstagramOAuthWithMetadata | CustomJwtWithMetadata | FarcasterWithMetadata | TelegramWithMetadata | CrossAppAccountWithMetadata | PasskeyAccountWithMetadata;
type LinkedAccountInput = Array<DistributiveOmit<LinkedAccountWithMetadata, 'verifiedAt' | 'firstVerifiedAt' | 'latestVerifiedAt'>>;
interface AdditionalSignerInput {
    /** The public key of the additional signer. */
    signerId: string;
    /** The policy IDs that apply to the additional signer. */
    policyIds: string[];
}
interface EmbeddedWalletCreationInput {
    /** The wallet chain type. */
    additionalSigners?: AdditionalSignerInput[];
    /** The policy IDs that apply to the embedded wallet. */
    policyIds: string[];
    /** The wallet chain type. */
    chainType: ChainType;
    /** If true, create a smart wallet with the embedded wallet as the signer. Defaults to false. */
    createSmartWallet?: boolean;
}
interface CreateWalletInput {
    /** The user's Privy-issued DID. */
    userId: string;
    /** The wallets to create for this user. */
    wallets?: EmbeddedWalletCreationInput[];
    /** If true, create an Ethereum embedded wallet for this user. Defaults to false. */
    createEthereumWallet?: boolean;
    /** If true, create a Solana embedded wallet for this user. Defaults to false. */
    createSolanaWallet?: boolean;
    /**
     * If true, create a smart wallet for this user. Defaults to false.
     * Requires `createEthereumWallet` to also be true.
     */
    createEthereumSmartWallet?: boolean;
    /**
     * The number of HD Ethereum embedded wallets to create for this user. Defaults to 1.
     * Requires `createEthereumWallet` to also be true.
     */
    numberOfEthereumWalletsToCreate?: number;
}
interface ImportUserInput {
    /** The user's linked accounts. */
    linkedAccounts: LinkedAccountInput;
    /** The wallets to create for this user. */
    wallets?: EmbeddedWalletCreationInput[];
    /** If true, create an Ethereum embedded wallet for this user. Defaults to false. */
    createEthereumWallet?: boolean;
    /** If true, create a Solana embedded wallet for this user. Defaults to false. */
    createSolanaWallet?: boolean;
    /**
     * If true, create a smart wallet for this user. Defaults to false.
     * Requires `createEthereumWallet` to also be true.
     */
    createEthereumSmartWallet?: boolean;
    /** Custom metadata to associate with the user. */
    customMetadata?: CustomMetadataType;
    /** @deprecated Use `createEthereumWallet` instead. */
    createEmbeddedWallet?: boolean;
}
interface User {
    /** The Privy-issued DID for the user. If you need to store additional information
     * about a user, you can use this DID to reference them. */
    id: string;
    /** The datetime of when the user was created. */
    createdAt: Date;
    /** Whether or not the user is a guest. */
    isGuest: boolean;
    /** Custom metadata set for the user */
    customMetadata: CustomMetadataType;
    /** The user's email address, if they have linked one. It cannot be linked to another user. */
    email?: Omit<EmailWithMetadata, 'type'>;
    /** The user's phone number, if they have linked one. It cannot be linked to another user. */
    phone?: Omit<PhoneWithMetadata, 'type'>;
    /** The user's most recently-linked wallet address, if they have linked at least one wallet.
     * It cannot be linked to another user.
     **/
    wallet?: Omit<WalletWithMetadata, 'type'>;
    /**
     * The user's smart wallet, if they have set up through the Privy Smart Wallet SDK.
     */
    smartWallet?: Omit<SmartWalletWithMetadata, 'type'>;
    /** The user's Google account, if they have linked one. It cannot be linked to another user. */
    google?: Omit<GoogleOAuthWithMetadata, 'type'>;
    /** The user's Twitter account, if they have linked one. It cannot be linked to another user. */
    twitter?: Omit<TwitterOAuthWithMetadata, 'type'>;
    /** The user's Discord account, if they have linked one. It cannot be linked to another user. */
    discord?: Omit<DiscordOAuthWithMetadata, 'type'>;
    /** The user's Github account, if they have linked one. It cannot be linked to another user. */
    github?: Omit<GithubOAuthWithMetadata, 'type'>;
    /** The user's Apple account, if they have linked one. It cannot be linked to another user. */
    apple?: Omit<AppleOAuthWithMetadata, 'type'>;
    /** The user's Tiktok account, if they have linked one. It cannot be linked to another user. */
    tiktok?: Omit<TiktokOAuthWithMetadata, 'type'>;
    /** The user's LinkedIn account, if they have linked one. It cannot be linked to another user. */
    linkedin?: Omit<LinkedInOAuthWithMetadata, 'type'>;
    /** The user's Spotify account, if they have linked one. It cannot be linked to another user. */
    spotify?: Omit<SpotifyOAuthWithMetadata, 'type'>;
    /** The user's Instagram account, if they have linked one. It cannot be linked to another user. */
    instagram?: Omit<InstagramOAuthWithMetadata, 'type'>;
    /** The user's Custom JWT account, if they have linked one. It cannot be linked to another user. */
    custom?: Omit<CustomJwtWithMetadata, 'type'>;
    /** The user's Farcaster account, if they have linked one. It cannot be linked to another user. */
    farcaster?: Omit<FarcasterWithMetadata, 'type'>;
    /** The user's Telegram account, if they have linked one. It cannot be linked to another user. */
    telegram?: Omit<TelegramWithMetadata, 'type'>;
    /** The list of accounts associated with this user. Each account contains additional metadata
     * that may be helpful for advanced use cases. */
    linkedAccounts: Array<LinkedAccountWithMetadata>;
}
interface AppSettings {
    id?: string;
    name?: string;
    verificationKey: string;
    logoUrl?: string;
    theme?: 'System' | 'Light' | 'Dark' | string;
    accentColor?: string;
    walletAuth?: boolean;
    emailAuth?: boolean;
    smsAuth?: boolean;
    googleOAuth?: boolean;
    twitterOAuth?: boolean;
    discordOAuth?: boolean;
    githubOAuth?: boolean;
    appleOAuth?: boolean;
    linkedInOAuth?: boolean;
    tiktokOAuth?: boolean;
    disablePlusEmails?: boolean;
    allowlistEnabled: boolean;
    allowlistConfig: {
        errorTitle: string | null;
        errorDetail: string | null;
        ctaText: string | null;
        ctaLink: string | null;
    };
    termsAndConditionsUrl: string | null;
    privacyPolicyUrl: string | null;
    createdAt?: Date;
    updatedAt?: Date;
}
interface AuthTokenClaims {
    appId: string;
    issuer: string;
    issuedAt: number;
    expiration: number;
    sessionId: string;
    userId: string;
}
type AllowlistEntryType = 'email' | 'phone' | 'wallet';
interface AllowlistEntry {
    id: string;
    type: AllowlistEntryType;
    value: string;
    appId: string;
}
type AllowlistEntryInput = Pick<AllowlistEntry, 'type' | 'value'>;
/**
 * Get multiple users by email, phone number, and wallet address.
 */
type BulkParams = {
    /** Get users by email addresses. Use this for getting multiple users by email address. */
    emails?: string[];
    /** Get users by phone number. Use this for getting multiple users by phone number */
    phoneNumbers?: string[];
    /** Get users by wallet address. Use this for getting multiple users by wallet address */
    walletAddresses?: string[];
};
/** Object containing the relevant headers of an incoming webhook */
type WebhooksVerificationHeaderInput = {
    id: string;
    timestamp: string;
    signature: string;
};
type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};
type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;

interface DefaultsType {
    baseURL: string;
    timeout: number;
}
type Axios = typeof redaxios__default;
type AxiosRequestConfig = Parameters<Axios>[1];
declare class Http {
    private instance;
    private sdkVersion;
    baseURL: string;
    constructor(appId: string, appSecret: string, { baseURL, timeout }: DefaultsType);
    get<T>(path: string, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    post<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    patch<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
    delete<T = any, D = any>(path: string, data?: D, config?: AxiosRequestConfig): Promise<redaxios.Response<T>>;
}

/**
 * Helper type to insert the following fields into RPC bodies depending on how they are used:
 * - Delegated actions: adds {address: string; chainType: 'solana' | 'ethereum'}
 * - Server wallets: adds {walletId: string}
 *
 */
type WithWalletIdOrAddressChainType<T, U extends 'solana' | 'ethereum'> = Prettify<T & {
    /**
     * Address of the wallet.
     * @deprecated Use walletId instead
     */
    address: string;
    /**
     * Chain type of the wallet.
     * @deprecated Use walletId instead
     */
    chainType: U;
}> | Prettify<T & {
    /** ID of the wallet. */
    walletId: string;
}>;
/**
 * Helper to insert an idempotencyKey field into request bodies
 */
type WithOptionalIdempotencyKey<T> = Prettify<T & {
    idempotencyKey?: string;
}>;

type Hex = `0x${string}`;
type Quantity = Hex | number;
type EthereumRpcWrapper<T> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<T, 'ethereum'>>;
/**
 * CAIP-2 chain IDs for EVM networks.
 */
type EvmCaip2ChainId = `eip155:${string}`;
/**
 * Inputs for the `privy.walletApi.ethereum.signMessage(...) method.
 */
type EthereumSignMessageInputType = EthereumRpcWrapper<{
    /** Message to sign as a UTF-8 string, a hex string, or an array of bytes. */
    message: string | Uint8Array;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.signTypedData(...) method.
 */
type EthereumSignTypedDataInputType = EthereumRpcWrapper<{
    /** EIP712 typed data to sign. */
    typedData: {
        domain: Record<string, any>;
        types: Record<string, any>;
        message: Record<string, any>;
        primaryType: string;
    };
}>;
type EthereumBaseTransactionInputType = {
    transaction: {
        /** The address the transaction is sent from. Must be hexadecimal formatted. */
        from?: Hex;
        /** Destination address of the transaction. */
        to?: Hex;
        /** The nonce to be used for the transaction (hexadecimal or number). */
        nonce?: Quantity;
        /** (optional) The chain ID of network your transaction will  be sent on. */
        chainId?: Quantity;
        /** (optional) Data to send to the receiving address, especially when calling smart contracts. Must be hexadecimal formatted. */
        data?: Hex;
        /** (optional) The value (in wei) be sent with the transaction (hexadecimal or number). */
        value?: Quantity;
        /** (optional) The EIP-2718 transction type (e.g. `2` for EIP-1559 transactions). */
        type?: 0 | 1 | 2;
        /** (optional) The max units of gas that can be used by this transaction (hexadecimal or number). */
        gasLimit?: Quantity;
        /** (optional) The price (in wei) per unit of gas for this transaction (hexadecimal or number), for use in non EIP-1559 transactions (type 0 or 1). */
        gasPrice?: Quantity;
        /** (optional) The maxFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
        maxFeePerGas?: Quantity;
        /** (optional) The maxPriorityFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
        maxPriorityFeePerGas?: Quantity;
    };
};
/**
 * Inputs for the `privy.walletApi.ethereum.signTransaction(...) method.
 */
type EthereumSignTransactionInputType = EthereumRpcWrapper<EthereumBaseTransactionInputType>;
/**
 * Inputs for the `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type EthereumSendTransactionInputType = EthereumRpcWrapper<EthereumBaseTransactionInputType & {
    /** CAIP-2 chain ID for the network to broadcast the transaction on. */
    caip2: EvmCaip2ChainId;
    /** Optional sponsor parameter to enable gas sponsorship for this transaction. */
    sponsor?: boolean;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.secp256k1Sign(...) method.
 */
type EthereumSecp256k1SignInputType = EthereumRpcWrapper<{
    /** The hash to sign. */
    hash: Hex;
}>;
/**
 * Inputs for the `privy.walletApi.ethereum.sign7702Authorization(...) method.
 */
type EthereumSign7702AuthorizationInputType = EthereumRpcWrapper<{
    /** Contract address to authorize. */
    contract: Hex;
    /** Chain id of the contract. */
    chainId: Quantity;
    /** (optional) The nonce to be used for the authorization. */
    nonce?: Quantity;
}>;
type EthereumRpcInputTypes = EthereumSignMessageInputType | EthereumSignTypedDataInputType | EthereumSignTransactionInputType | EthereumSendTransactionInputType | EthereumSecp256k1SignInputType | EthereumSign7702AuthorizationInputType;
/** Response for the `privy.walletApi.ethereum.signMessage(...) method. */
type EthereumSignMessageResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.secp256k1Sign(...) method. */
type EthereumSecp256k1SignResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.signTypedData(...) method. */
type EthereumSignTypedDataResponseType = {
    /** Signature produced by the wallet. */
    signature: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.signTransaction(...) method. */
type EthereumSignTransactionResponseType = {
    /** Signed transaction by the wallet. */
    signedTransaction: string;
    /** Encoding of the signature. */
    encoding: string;
};
/** Response for the `privy.walletApi.ethereum.sendTransaction(...) method. */
type EthereumSendTransactionResponseType = {
    /** Hash for the broadcasted transaction. */
    hash: string;
    /** CAIP-2 chain ID for the network the transaction was broadcasted on. */
    caip2: EvmCaip2ChainId;
};
/** Response for the `privy.walletApi.ethereum.sign7702Authorization(...) method. */
type EthereumSign7702AuthorizationResponseType = {
    /** Chain id of the contract. */
    chainId: Quantity;
    /** Contract address to authorize. */
    contract: Hex;
    /** Nonce used for the authorization. */
    nonce: Quantity;
    /** Y parity of the signature. */
    yParity: number;
    /** R value of the signature. */
    r: Hex;
    /** S value of the signature. */
    s: Hex;
};

declare class EthereumRpcApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey: bigint | null;
    });
    /**
     * Method to sign a message with an Ethereum wallet using the 'personal_sign' RPC.
     *
     * @param input {EthereumSignMessageInputType} message to sign
     * @returns {EthereumSignMessageResponseType} signature and encoding of signature
     */
    signMessage(input: EthereumSignMessageInputType): Promise<EthereumSignMessageResponseType>;
    secp256k1Sign(input: EthereumSecp256k1SignInputType): Promise<EthereumSecp256k1SignResponseType>;
    /**
     * Method to sign an EIP712 typed data message with an Ethereum wallet using the
     * 'eth_signTypedData_v4' RPC.
     *
     * @param input {EthereumSignTypedData} typed data message to sign
     * @returns {EthereumSignTypedDataResponseType} signature and encoding of signature
     */
    signTypedData(input: EthereumSignTypedDataInputType): Promise<EthereumSignTypedDataResponseType>;
    /**
     * Method to sign a transaction with an Ethereum wallet using the 'eth_signTransaction' RPC.
     *
     * @param input {EthereumSignTransactionInputType} transaction to sign
     * @returns {EthereumSignTransactionResponseType} signed transaction and encoding of signature
     */
    signTransaction(input: EthereumSignTransactionInputType): Promise<EthereumSignTransactionResponseType>;
    /**
     * Method to sign and send a transaction with an Ethereum wallet using the
     * 'eth_sendTransaction' RPC.
     *
     * @param input {EthereumSendTransactionInputType} transaction to send and CAIP-2 chain ID for the transaction
     * @returns {EthereumSendTransactionResponseType} transaction hash and CAIP-2 chain ID for the transaction's network
     */
    sendTransaction(input: EthereumSendTransactionInputType): Promise<EthereumSendTransactionResponseType>;
    /**
     * Method to sign an EIP-7702 authorization with an Ethereum wallet using the
     * 'eth_sign7702Authorization' RPC.
     *
     * @param input {EthereumSign7702AuthorizationInputType} authorization to sign
     * @returns {EthereumSign7702AuthorizationResponseType} signed authorization object
     */
    sign7702Authorization(input: EthereumSign7702AuthorizationInputType): Promise<EthereumSign7702AuthorizationResponseType>;
}

/**
 * CAIP-2 chain IDs for Solana mainnet, devnet, and testnet
 *
 * - Mainnet: 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
 * - Devnet: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
 * - Testnet: 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'
 */
type SolanaCaip2ChainId = 
/** Solana mainnet CAIP-2 chain ID */
'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
/** Solana devnet CAIP-2 chain ID */
 | 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
/** Solana testnet CAIP-2 chain ID */
 | 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z';
type SolanaRpcWrapper<T> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<T, 'solana'>>;
/** Input for the `privy.walletApi.solana.signMessage(...)` method. */
type SolanaSignMessageInputType = SolanaRpcWrapper<{
    /** Message to sign with the wallet. */
    message: string | Uint8Array;
}>;
/** Input for the `privy.walletApi.solana.signTransaction(...)` method. */
type SolanaSignTransactionInputType = SolanaRpcWrapper<{
    /** Transaction object to sign with the wallet */
    transaction: Transaction | VersionedTransaction;
}>;
/** Input for the `privy.walletApi.solana.sendTransaction(...)` method. */
type SolanaSignAndSendTransactionInputType = SolanaRpcWrapper<{
    /** Transaction object to sign with the wallet */
    transaction: Transaction | VersionedTransaction;
    /** CAIP-2 chain ID for the Solana network to broadcast the transaction on. */
    caip2: SolanaCaip2ChainId;
    /** Optional sponsor parameter to enable gas sponsorship for this transaction. */
    sponsor?: boolean;
}>;
type SolanaRpcInputTypes = SolanaSignMessageInputType | SolanaSignTransactionInputType | SolanaSignAndSendTransactionInputType;
/** Response  for the `privy.walletApi.solana.signMessage(...)` method. */
type SolanaSignMessageResponseType = {
    /** Signature produced by the wallet. */
    signature: Uint8Array;
};
/** Response for the `privy.walletApi.solana.signTransaction(...)` method. */
type SolanaSignTransactionResponseType = {
    /** Signed transaction object. */
    signedTransaction: Transaction | VersionedTransaction;
};
/** Response for the `privy.walletApi.solana.signAndSendTransaction(...) method. */
type SolanaSignAndSendTransactionResponseType = {
    /** Hash for the broadcasted transaction. */
    hash: string;
    /** CAIP-2 chain ID for the network the transaction was broadcasted on. */
    caip2: SolanaCaip2ChainId;
};

/**
 * @deprecated Use `SolanaSignMessageInputType` instead with the
 * `privy.walletApi.solana.signMessage(...) method.
 */
type SolanaSignMessageRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'signMessage';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** Message to sign with the wallet. */
        message: string | Uint8Array;
    };
}, 'solana'>>;
type SolanaBaseTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = {
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** transaction object to sign with the wallet */
        transaction: TTransactionType;
    };
};
/**
 * @deprecated Use `SolanaSignTransactionInputType` instead with the
 * `privy.walletApi.solana.signTransaction(...) method.
 *
 * The input parameters for the `signTransaction` RPC method to sign a Solana transaction.
 * If you use this type directly you can optionally narrow it to just `Transaction` or `VersionedTransaction`,
 * like `SolanaSignTransactionRpcInputType<VersionedTransaction>`.
 * Otherwise, the `rpc` method will determine the type of transaction you passed in and return the appropriate type.
 */
type SolanaSignTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<SolanaBaseTransactionRpcInputType<TTransactionType> & {
    /** RPC method to execute with the wallet.  */
    method: 'signTransaction';
}, 'solana'>>;
/**
 *  * @deprecated Use `SolanaSignAndSendTransactionInputType` instead with the
 * `privy.walletApi.solana.signAndSendTransaction(...) method.
 *
 * The input parameters for the `signAndSendTransaction` RPC method to sign a Solana transaction.
 * If you use this type directly you can optionally narrow it to just `Transaction` or `VersionedTransaction`,
 * like `SolanaSignAndSendTransactionRpcInputType<VersionedTransaction>`.
 * Otherwise, the `rpc` method will determine the type of transaction you passed in and return the appropriate type.
 */
type SolanaSignAndSendTransactionRpcInputType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<SolanaBaseTransactionRpcInputType<TTransactionType> & {
    /** RPC method to execute with the wallet.  */
    method: 'signAndSendTransaction';
    /**
     * CAIP-2 chain ID for the Solana network to broadcast the transaction on.
     **/
    caip2: SolanaCaip2ChainId;
}, 'solana'>>;
/**
 * @deprecated Use `EthereumSignTypedDataInputType` instead with the
 * `privy.walletApi.ethereum.signTypedData(...) method.
 */
type EthereumSignTypedDataRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'eth_signTypedData_v4';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        typedData: {
            domain: Record<string, any>;
            types: Record<string, any>;
            message: Record<string, any>;
            primaryType: string;
        };
    };
}, 'ethereum'>>;
/**
 * @deprecated Use `EthereumSignMessageInputType` instead with the
 * `privy.walletApi.ethereum.signMessage(...) method.
 */
type EthereumPersonalSignRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<{
    /** RPC method to execute with the wallet.  */
    method: 'personal_sign';
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        message: string | Uint8Array;
    };
}, 'ethereum'>>;
type EthereumBaseTransactionRpcInputType = {
    /** Parameters for the RPC method that the wallet will execute. */
    params: {
        /** The transaction object to sign with the wallet. */
        transaction: {
            /** The address the transaction is sent from. Must be hexadecimal formatted. */
            from?: Hex;
            /** Destination address of the transaction. */
            to?: Hex;
            /** The nonce to be used for the transaction (hexadecimal or number). */
            nonce?: Quantity;
            /** (optional) The chain ID of network your transaction will  be sent on. */
            chainId?: Quantity;
            /** (optional) Data to send to the receiving address, especially when calling smart contracts. Must be hexadecimal formatted. */
            data?: Hex;
            /** (optional) The value (in wei) be sent with the transaction (hexadecimal or number). */
            value?: Quantity;
            /** (optional) The EIP-2718 transction type (e.g. `2` for EIP-1559 transactions). */
            type?: 0 | 1 | 2;
            /** (optional) The max units of gas that can be used by this transaction (hexadecimal or number). */
            gasLimit?: Quantity;
            /** (optional) The price (in wei) per unit of gas for this transaction (hexadecimal or number), for use in non EIP-1559 transactions (type 0 or 1). */
            gasPrice?: Quantity;
            /** (optional) The maxFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
            maxFeePerGas?: Quantity;
            /** (optional) The maxPriorityFeePerGas (hexadecimal or number) to be used in this transaction, for use in EIP-1559 (type 2) transactions. */
            maxPriorityFeePerGas?: Quantity;
        };
    };
};
/**
 * @deprecated Use `EthereumSignTransactionInputType` instead with the
 * `privy.walletApi.ethereum.signTransaction(...) method.
 */
type EthereumSignTransactionRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<EthereumBaseTransactionRpcInputType & {
    /** RPC method to execute with the wallet.  */
    method: 'eth_signTransaction';
}, 'ethereum'>>;
/**
 * @deprecated Use `EthereumSendTransactionInputType` instead with the
 * `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type EthereumSendTransactionRpcInputType = WithOptionalIdempotencyKey<WithWalletIdOrAddressChainType<EthereumBaseTransactionRpcInputType & {
    /** RPC method to execute with the wallet.  */
    method: 'eth_sendTransaction';
    /** CAIP-2 chain ID for the EVM network to broadcast the transaction on. */
    caip2: EvmCaip2ChainId;
}, 'ethereum'>>;
type WalletApiRpcInputType = SolanaSignMessageRpcInputType | SolanaSignTransactionRpcInputType | SolanaSignAndSendTransactionRpcInputType | EthereumSignTypedDataRpcInputType | EthereumPersonalSignRpcInputType | EthereumSignTransactionRpcInputType | EthereumSendTransactionRpcInputType;
/**
 * @deprecated Use `SolanaSignTransactionResponseType` instead from the
 * `privy.walletApi.solana.signTransaction(...) method.
 */
type WalletApiSolanaSignTransactionRpcResponseType<TTransactionType extends Transaction | VersionedTransaction = VersionedTransaction | Transaction> = {
    /** RPC method executed by the wallet. */
    method: 'signTransaction';
    /** Data returned from the RPC method. */
    data: {
        /** Signed transaction object produced by the wallet. */
        signedTransaction: TTransactionType;
    };
};
/**
 * @deprecated Use `SolanaSignAndSendTransactionResponseType` instead from the
 * `privy.walletApi.solana.signAndSendTransaction(...) method.
 */
type WalletApiSolanaSignAndSendTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'signAndSendTransaction';
} & ({
    /** Data returned from the RPC method. */
    data: {
        /** A Privy-assigned id for the sent transaction. */
        transactionId?: string;
        /** Transaction hash. */
        hash: string;
        /** CAIP-2 chain ID of the Solana network the transaction was broadcasted on. */
        caip2: SolanaCaip2ChainId;
    };
} | {
    error: {
        /** Error code. */
        code: string;
        /** Error message. */
        message: string;
    };
});
/**
 * @deprecated Use `SolanaSignMessageResponseType` instead from the
 * `privy.walletApi.solana.signMessage(...) method.
 */
type WalletApiSolanaSignMessageRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'signMessage';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: Uint8Array;
    };
};
/**
 * @deprecated Use `EthereumSignTypedDataResponseType` instead from the
 * `privy.walletApi.ethereum.signTypedData(...) method.
 */
type WalletApiEthereumSignTypedDataRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_signTypedData_v4';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: string;
        /** Encoding of the signature. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSignMessageResponseType` instead from the
 * `privy.walletApi.ethereum.signMessage(...) method.
 */
type WalletApiEthereumPersonalSignRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'personal_sign';
    /** Data returned from the RPC method. */
    data: {
        /** Signature produced by the wallet. */
        signature: string;
        /** Encoding of the signature. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSignTransactionResponseType` instead from the
 * `privy.walletApi.ethereum.signTransaction(...) method.
 */
type WalletApiEthereumSignTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_signTransaction';
    /** Data returned from the RPC method. */
    data: {
        /** Signed transaction object produced by the wallet. */
        signedTransaction: string;
        /** Encoding of the signed transaction. */
        encoding: string;
    };
};
/**
 * @deprecated Use `EthereumSendTransactionResponseType` instead from the
 * `privy.walletApi.ethereum.sendTransaction(...) method.
 */
type WalletApiEthereumSendTransactionRpcResponseType = {
    /** RPC method executed by the wallet. */
    method: 'eth_sendTransaction';
} & ({
    /** Data returned from the RPC method. */
    data: {
        /** A Privy-assigned id for the sent transaction. */
        transactionId?: string;
        /** Transaction hash. */
        hash: string;
        /** CAIP-2 chain ID of the EVM network the transaction was broadcasted on. */
        caip2: EvmCaip2ChainId;
    };
} | {
    error: {
        /** Error code. */
        code: string;
        /** Error message. */
        message: string;
    };
});
type WalletApiRpcResponseType = WalletApiSolanaSignTransactionRpcResponseType | WalletApiSolanaSignMessageRpcResponseType | WalletApiSolanaSignAndSendTransactionRpcResponseType | WalletApiEthereumSignTypedDataRpcResponseType | WalletApiEthereumPersonalSignRpcResponseType | WalletApiEthereumSignTransactionRpcResponseType | WalletApiEthereumSendTransactionRpcResponseType;

type BaseWalletCreateInput = {
    /** Chain type for the created wallet. */
    chainType: ChainType;
    /** Policy IDs to assign to the wallet */
    policyIds?: string[];
};
type AdditionalSignersInput = {
    /** Additional signers for the wallet */
    additionalSigners?: {
        signerId: string;
        overridePolicyIds?: string[];
    }[];
};
type SignersInput = XOR<{
    authorizationKeyIds?: string[];
    authorizationThreshold?: number;
}, AdditionalSignersInput>;
type OwnerObject = {
    owner?: XOR<{
        /** The user ID of the owner */
        userId: string;
    }, {
        /** The public key of the owner */
        publicKey: string;
    }>;
};
type OwnerIdInput = {
    /** The ID of the Key Quorum to use for the owner */
    ownerId?: string;
};
type OwnerInput = XOR<OwnerObject, OwnerIdInput>;
type WalletApiCreateRequestType = WithOptionalIdempotencyKey<BaseWalletCreateInput & OwnerInput & SignersInput>;
type BaseWalletUpdateInput = {
    /** Unique ID for the wallet to update */
    id: string;
    /** Policy IDs to assign to the wallet */
    policyIds?: string[];
};
type WalletApiUpdateRequestType = WithOptionalIdempotencyKey<BaseWalletUpdateInput & OwnerInput & AdditionalSignersInput>;
type WalletApiRpcInputTypes = EthereumRpcInputTypes | SolanaRpcInputTypes;
type WalletApiWalletResponseType = {
    /** Unique ID for the created wallet. Used to take actions with the wallet after creation. */
    id: string;
    /** Chain type for the created wallet. */
    chainType: ChainType;
    /** Address for the created wallet */
    address: string;
    /** Public key for the created wallet */
    publicKey?: string;
    /** Policy IDs that have been assigned to the wallet. */
    policyIds: string[];
    /** The owner of the wallet's key quorum ID */
    ownerId: string | null;
    /** Additional signers for the wallet */
    additionalSigners?: {
        /** The key quorum ID of the signer */
        signerId: string;
        /** The IDs of the policies that apply to the signer */
        overridePolicyIds?: string[];
    }[];
    /** The creation date of the wallet */
    createdAt: Date;
    /** The date the wallet was imported */
    importedAt: Date | null;
    /** The date the wallet was exported */
    exportedAt: Date | null;
};
type WalletApiFindWalletsRequestType = {
    /** Cursor used to paginate results */
    cursor?: string;
    /** Maximum results per page */
    limit?: number;
    /** Chain type to filter by. */
    chainType?: ChainType;
};
type WalletApiFindWalletsResponseType = {
    /** List of wallets */
    data: Array<WalletApiWalletResponseType>;
    /** Cursor for the next page */
    nextCursor?: string;
};
type WalletApiTransactionResponseType = {
    /** Unique ID for the transaction */
    id: string;
    /** Wallet ID for the transaction */
    walletId: string;
    /** CAIP2 for the transaction */
    caip2: string;
    /** Transaction hash for the transaction */
    transactionHash: string | null;
    /** Status of the transaction */
    status: 'broadcasted' | 'confirmed' | 'delayed' | 'execution_reverted' | 'failed' | 'replaced';
};
type PolicyMethod = 'eth_signTransaction' | 'eth_sendTransaction' | 'eth_signTypedData_v4' | 'eth_sign7702Authorization' | 'signAndSendTransaction' | 'signTransaction' | 'exportPrivateKey' | '*';
type PolicyRuleConditionOperator = 'eq' | 'gt' | 'gte' | 'lt' | 'lte' | 'in';
type WalletApiPolicyRuleResponseType = WalletApiPolicyRuleType & {
    /** Unique ID for the rule */
    id: string;
};
type WalletApiPolicyResponseType = {
    /** Unique ID for the policy */
    id: string;
    /** Name of the policy */
    name: string;
    /** Version of the policy */
    version: '1.0';
    /** Chain type of the policy */
    chainType: ChainType;
    /** Rules of the policy per RPC method */
    rules: WalletApiPolicyRuleResponseType[];
    /** Creation date of the policy */
    createdAt: Date;
};
type WalletApiPolicyOwnerInput = XOR<{
    /** The ID of the Key Quorum to use for the owner */
    ownerId?: string;
}, {
    owner?: {
        /** The public key of the owner */
        publicKey: string;
    };
}>;
type WalletApiPolicyCreateRequestType = {
    /** Name of the policy */
    name: string;
    /** Version of the policy */
    version: '1.0';
    /** Chain type of the policy */
    chainType: 'ethereum' | 'solana';
    /** Rules of the policy per RPC method */
    rules: WalletApiPolicyRuleType[];
} & WalletApiPolicyOwnerInput;
type WalletApiPolicyUpdateRequestType = {
    /** ID of the policy */
    id: string;
    /** Name of the policy */
    name?: string;
    /** Rules of the policy per RPC method */
    rules?: WalletApiPolicyRuleType[];
};
type WalletApiPolicyDeleteRequestType = {
    /** ID of the policy */
    id: string;
};
type WalletApiPolicyRuleType = {
    /** @deprecated Unused parameter */
    id?: string;
    name: string;
    action: PolicyActionType;
    method: PolicyMethod;
    conditions: WalletApiPolicyRuleConditionType[];
};
type WalletApiPolicyRuleCreateRequestType = {
    /** ID of the policy */
    policyId: string;
    /** Name of the rule */
    name: string;
    /** Action of the rule */
    action: PolicyActionType;
    /** Method of the rule */
    method: PolicyMethod;
    /** Conditions of the rule */
    conditions: WalletApiPolicyRuleConditionType[];
};
type WalletApiPolicyRuleUpdateRequestType = WalletApiPolicyRuleCreateRequestType & {
    /** ID of the rule */
    ruleId: string;
};
type WalletApiPolicyRuleDeleteRequestType = {
    /** ID of the policy */
    policyId: string;
    /** ID of the rule */
    ruleId: string;
};
type WalletApiPolicyRuleGetRequestType = WalletApiPolicyRuleDeleteRequestType;
type WalletApiPolicyRuleConditionType = WalletApiPolicyEthereumTransactionCondition | WalletApiPolicyEthereumCalldataCondition | WalletApiPolicyEthereumTypedDataDomainCondition | WalletApiPolicyEthereumTypedDataMessageCondition | WalletApiPolicyEthereum7702AuthorizationCondition | WalletApiPolicySolanaProgramInstructionCondition | WalletApiPolicySolanaSystemProgramInstructionCondition | WalletApiPolicySolanaTokenProgramInstructionCondition;
type WalletApiPolicyEthereumTransactionCondition = {
    fieldSource: 'ethereum_transaction';
    field: 'to' | 'value';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicyEthereumCalldataCondition = {
    fieldSource: 'ethereum_calldata';
    field: string;
    operator: PolicyRuleConditionOperator;
    value: string | string[];
    abi: any;
};
type WalletApiPolicyEthereumTypedDataDomainCondition = {
    fieldSource: 'ethereum_typed_data_domain';
    field: 'chain_id' | 'verifying_contract' | 'chainId' | 'verifyingContract';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicyEthereumTypedDataMessageCondition = {
    fieldSource: 'ethereum_typed_data_message';
    field: string;
    operator: PolicyRuleConditionOperator;
    value: string | string[];
    typedData: {
        types: Record<string, Array<{
            name: string;
            type: string;
        }>>;
        primaryType: string;
    };
};
type WalletApiPolicyEthereum7702AuthorizationCondition = {
    fieldSource: 'ethereum_7702_authorization';
    field: 'contract';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicySolanaProgramInstructionCondition = {
    fieldSource: 'solana_program_instruction';
    field: 'programId';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicySolanaSystemProgramInstructionCondition = {
    fieldSource: 'solana_system_program_instruction';
    field: 'instructionName' | 'Transfer.lamports' | 'Transfer.to' | 'Transfer.from';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiPolicySolanaTokenProgramInstructionCondition = {
    fieldSource: 'solana_token_program_instruction';
    field: 'instructionName' | 'TransferChecked.source' | 'TransferChecked.destination' | 'TransferChecked.authority' | 'TransferChecked.amount' | 'TransferChecked.mint';
    operator: PolicyRuleConditionOperator;
    value: string | string[];
};
type WalletApiRequestSignatureInput = {
    /** Signature version. 1 is currently the only valid version. */
    version: 1;
    /** Request method. Signatures are not required on 'GET' requests. */
    method: 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    /** URL for the request. Should not contain a trailing slash. */
    url: string;
    /** Request body. */
    body: any;
    /** Privy-specific headers. */
    headers: {
        'privy-app-id': string;
        'privy-idempotency-key'?: string;
    };
};
type WalletApiGenerateUserSignerResponseType = {
    /** The decrypted authorization key */
    authorizationKey: string;
    /** The expiration timestamp of the authorization key */
    expiresAt: Date;
    /** The wallets that this authorization key can be used for */
    wallets: Array<WalletApiWalletResponseType>;
};
type BaseImportWalletInputCommon = {
    /** The address of the wallet to import, in its native format (e.g. hex for Ethereum, base58 for Solana) */
    address: string;
    /** The chain type of the wallet to import */
    chainType: WalletImportSupportedChains;
    /** The entropy of the wallet to import in its native format (e.g. hex for Ethereum, base58 for Solana) */
    entropy: string;
};
type BaseImportWalletInputPrivateKey = BaseImportWalletInputCommon & {
    /** The entropy type of the wallet to import */
    entropyType: 'private-key';
};
type BaseImportWalletInputHD = BaseImportWalletInputCommon & {
    /** The entropy type of the wallet to import */
    entropyType: 'hd';
    /** The index of the HD wallet to import */
    index: number;
};
type BaseImportWalletInput = BaseImportWalletInputPrivateKey | BaseImportWalletInputHD;
type WalletApiImportWalletRequestType = BaseImportWalletInput & OwnerInput & SignersInput;

declare class SolanaRpcApi {
    private appId;
    private api;
    private authorizationPrivateKey;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey: bigint | null;
    });
    /**
     * Method to sign a message with an Solana wallet using the 'signMessage' RPC.
     *
     * @param input {SolanaSignMessageInputType} message to sign
     * @returns {SolanaSignMessageResponseType} signature and encoding of signature
     */
    signMessage(input: SolanaSignMessageInputType): Promise<SolanaSignMessageResponseType>;
    /**
     * Method to sign a transaction with an Solana wallet using the 'signTransaction' RPC.
     *
     * @param input {SolanaSignTransactionInputType} transaction to sign
     * @returns {SolanaSignTransactionResponseType} signed transaction
     */
    signTransaction(input: SolanaSignTransactionInputType): Promise<{
        signedTransaction: _solana_web3_js.Transaction | _solana_web3_js.VersionedTransaction;
    }>;
    /**
     * Method to sign and send a transaction with an Solana wallet using the 'signAndSendTransaction' RPC.
     *
     * @param input {SolanaSignAndSendTransactionType} transaction to sign and broadcast
     * @returns {SolanaSignAndSendTransactionResponseType} transaction hash
     */
    signAndSendTransaction(input: SolanaSignAndSendTransactionInputType): Promise<{
        hash: string;
        caip2: SolanaCaip2ChainId;
    }>;
}

/**
 * Class to support making RPC requests to the Privy wallets API. When the Privy client
 * is constructed, this class is also constructed and will be set as the `.walletApi` field
 * for the client.
 */
declare class WalletApi {
    #private;
    private appId;
    private api;
    private authorizationPrivateKey;
    ethereum: EthereumRpcApi;
    solana: SolanaRpcApi;
    constructor({ appId, api, authorizationPrivateKey, }: {
        /** Privy app ID */
        appId: string;
        /** HTTP instance from the Privy client to send RPC requests to the Privy API */
        api: Http;
        /**
         * App's authorization private key for wallets. This is only required
         * to produce authorization signatures if the app has an authorization keypair
         * enabled in the dashboard.
         */
        authorizationPrivateKey?: string;
    });
    getWallets(input?: WalletApiFindWalletsRequestType): Promise<WalletApiFindWalletsResponseType>;
    getWallet({ id, }: {
        /** ID for the wallet to fetch. */
        id: string;
    }): Promise<WalletApiWalletResponseType>;
    /**
     * Updates the authorization key used for signing requests to the Privy Wallets API.
     *
     * @param authorizationPrivateKey The new authorization private key to use for signing requests.
     */
    updateAuthorizationKey(authorizationPrivateKey: string): void;
    /**
     * Generates a user signer for the given user JWT.
     *
     * The user signer can then be used to securely sign API requests
     * on behalf of the user.
     *
     * @param userJwt - The user JWT to generate the user signer.
     * @returns {WalletApiGenerateUserSignerResponseType} - The generated user signer containing the authorization key, expiration date, and associated wallets.
     */
    generateUserSigner({ userJwt, }: {
        /** User JWT to generate the user signer */
        userJwt: string;
    }): Promise<WalletApiGenerateUserSignerResponseType>;
    getPolicy({ id }: {
        id: string;
    }): Promise<WalletApiPolicyResponseType>;
    createPolicy(input: WalletApiPolicyCreateRequestType): Promise<WalletApiPolicyResponseType>;
    updatePolicy(input: WalletApiPolicyUpdateRequestType): Promise<WalletApiPolicyResponseType>;
    deletePolicy(input: WalletApiPolicyDeleteRequestType): Promise<void>;
    addRuleToPolicy(input: WalletApiPolicyRuleCreateRequestType): Promise<WalletApiPolicyRuleResponseType>;
    updateRuleInPolicy(input: WalletApiPolicyRuleUpdateRequestType): Promise<WalletApiPolicyRuleResponseType>;
    deleteRuleFromPolicy(input: WalletApiPolicyRuleDeleteRequestType): Promise<void>;
    getRuleInPolicy(input: WalletApiPolicyRuleGetRequestType): Promise<WalletApiPolicyRuleResponseType>;
    getTransaction({ id }: {
        id: string;
    }): Promise<WalletApiTransactionResponseType>;
    /**
     * @deprecated This is deprecated in favor of createWallet
     */
    create(input: WalletApiCreateRequestType): Promise<WalletApiWalletResponseType>;
    /**
     * Create a new Ethereum or Solana wallet
     * @param input @type {WalletApiCreateRequestType}
     * @returns @type {WalletApiWalletResponseType}
     */
    createWallet(input: WalletApiCreateRequestType): Promise<WalletApiWalletResponseType>;
    /**
     * Update a wallet
     * @param input @type {WalletApiUpdateRequestType}
     * @returns @type {WalletApiWalletResponseType}
     */
    updateWallet(input: WalletApiUpdateRequestType): Promise<WalletApiWalletResponseType>;
    /**
     * Import a wallet
     * @param input @type {WalletApiImportWalletRequestType}
     * @returns @type {WalletApiWalletResponseType}
     */
    importWallet(input: WalletApiImportWalletRequestType): Promise<WalletApiWalletResponseType>;
    /**
     * @deprecated Use specific methods on the `privy.walletApi.ethereum` and `privy.walletApi.solana` classes instead:
     * - `privy.walletApi.ethereum.{signMessage, signTypedData, signTransaction, sendTransaction}`
     * - `privy.walletApi.solana.{signMessage, signTransaction, signAndSendTransaction}`
     *
     * Executed RPC requests for the provided wallet.
     *
     * @returns data returned by executed RPC method
     */
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType<Transaction>): Promise<WalletApiSolanaSignTransactionRpcResponseType<Transaction>>;
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType<VersionedTransaction>): Promise<WalletApiSolanaSignTransactionRpcResponseType<VersionedTransaction>>;
    rpc(input: {
        method: 'signTransaction';
    } & SolanaSignTransactionRpcInputType): Promise<WalletApiSolanaSignTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType<Transaction>): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType<VersionedTransaction>): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signAndSendTransaction';
    } & SolanaSignAndSendTransactionRpcInputType): Promise<WalletApiSolanaSignAndSendTransactionRpcResponseType>;
    rpc(input: {
        method: 'signMessage';
    } & SolanaSignMessageRpcInputType): Promise<WalletApiSolanaSignMessageRpcResponseType>;
    rpc(input: {
        method: 'eth_signTransaction';
    } & EthereumSignTransactionRpcInputType): Promise<WalletApiEthereumSignTransactionRpcResponseType>;
    rpc(input: {
        method: 'personal_sign';
    } & EthereumPersonalSignRpcInputType): Promise<WalletApiEthereumPersonalSignRpcResponseType>;
    rpc(input: {
        method: 'eth_signTypedData_v4';
    } & EthereumSignTypedDataRpcInputType): Promise<WalletApiEthereumSignTypedDataRpcResponseType>;
    rpc(input: {
        method: 'eth_sendTransaction';
    } & EthereumSendTransactionRpcInputType): Promise<WalletApiEthereumSendTransactionRpcResponseType>;
}
/**
 * Generates an authorization signature for a given wallet API request.
 *
 * Use this signature in the `privy-authorization-signature` header to authorize your request.
 *
 * Typically, it is not required to call this manually, as providing an `authorizationPrivateKey` to the `WalletAPI` class
 * at instantiation will automatically sign and populate this header for all requisite RPC requests.
 * Manual signing of requests is intended for advanced use cases.
 *
 * @param input - The request payload to sign which should match the input of the WalletAPI method to be called.
 * @param authorizationPrivateKey - The authorization key used to sign the request.
 * @returns The signature of the request payload which should be used in the `privy-authorization-signature` header.
 */
declare function generateAuthorizationSignature({ input, authorizationPrivateKey, }: {
    input: WalletApiRequestSignatureInput;
    authorizationPrivateKey: string;
}): string | undefined;
/**
 * Formats and serializes a request payload that can be used to generate an authorization signature.
 * This function typically should not need to be called directly, except for advanced use cases.
 *
 * @param input - The request payload to format which should match the input of the WalletAPI method to be called.
 * @returns The formatted request payload which can be used to generate an authorization signature.
 */
declare function formatRequestForAuthorizationSignature({ input, }: {
    input: WalletApiRequestSignatureInput;
}): Buffer;

export { type WalletApiPolicyRuleResponseType as $, type AppSettings as A, type BulkParams as B, type CreateWalletInput as C, type Discord as D, type Email as E, type Farcaster as F, type Google as G, type Hex as H, type ImportUserInput as I, type LinkedAccountWithMetadata as J, type SignersInput as K, type LinkedIn as L, type WalletApiCreateRequestType as M, type WalletApiUpdateRequestType as N, type OwnerInput as O, type Phone as P, type WalletApiRpcInputTypes as Q, type WalletApiWalletResponseType as R, type Spotify as S, type Twitter as T, type User as U, type WalletApiFindWalletsRequestType as V, WalletApi as W, type WalletApiFindWalletsResponseType as X, type WalletApiTransactionResponseType as Y, type PolicyMethod as Z, type PolicyRuleConditionOperator as _, type AllowlistEntry as a, type WalletApiRpcResponseType as a$, type WalletApiPolicyResponseType as a0, type WalletApiPolicyCreateRequestType as a1, type WalletApiPolicyUpdateRequestType as a2, type WalletApiPolicyDeleteRequestType as a3, type WalletApiPolicyRuleType as a4, type WalletApiPolicyRuleCreateRequestType as a5, type WalletApiPolicyRuleUpdateRequestType as a6, type WalletApiPolicyRuleDeleteRequestType as a7, type WalletApiPolicyRuleGetRequestType as a8, type WalletApiPolicyRuleConditionType as a9, type EthereumSignTypedDataResponseType as aA, type EthereumSignTransactionResponseType as aB, type EthereumSendTransactionResponseType as aC, type EthereumSign7702AuthorizationResponseType as aD, type SolanaCaip2ChainId as aE, type SolanaSignMessageInputType as aF, type SolanaSignTransactionInputType as aG, type SolanaSignAndSendTransactionInputType as aH, type SolanaRpcInputTypes as aI, type SolanaSignMessageResponseType as aJ, type SolanaSignTransactionResponseType as aK, type SolanaSignAndSendTransactionResponseType as aL, type SolanaSignMessageRpcInputType as aM, type SolanaSignTransactionRpcInputType as aN, type SolanaSignAndSendTransactionRpcInputType as aO, type EthereumSignTypedDataRpcInputType as aP, type EthereumPersonalSignRpcInputType as aQ, type EthereumSignTransactionRpcInputType as aR, type EthereumSendTransactionRpcInputType as aS, type WalletApiRpcInputType as aT, type WalletApiSolanaSignTransactionRpcResponseType as aU, type WalletApiSolanaSignAndSendTransactionRpcResponseType as aV, type WalletApiSolanaSignMessageRpcResponseType as aW, type WalletApiEthereumSignTypedDataRpcResponseType as aX, type WalletApiEthereumPersonalSignRpcResponseType as aY, type WalletApiEthereumSignTransactionRpcResponseType as aZ, type WalletApiEthereumSendTransactionRpcResponseType as a_, type WalletApiPolicyEthereumTransactionCondition as aa, type WalletApiPolicyEthereumCalldataCondition as ab, type WalletApiPolicyEthereumTypedDataDomainCondition as ac, type WalletApiPolicyEthereumTypedDataMessageCondition as ad, type WalletApiPolicyEthereum7702AuthorizationCondition as ae, type WalletApiPolicySolanaProgramInstructionCondition as af, type WalletApiPolicySolanaSystemProgramInstructionCondition as ag, type WalletApiPolicySolanaTokenProgramInstructionCondition as ah, type WalletApiRequestSignatureInput as ai, type WalletApiGenerateUserSignerResponseType as aj, type BaseImportWalletInputCommon as ak, type BaseImportWalletInputPrivateKey as al, type BaseImportWalletInputHD as am, type BaseImportWalletInput as an, type WalletApiImportWalletRequestType as ao, type Quantity as ap, type EvmCaip2ChainId as aq, type EthereumSignMessageInputType as ar, type EthereumSignTypedDataInputType as as, type EthereumSignTransactionInputType as at, type EthereumSendTransactionInputType as au, type EthereumSecp256k1SignInputType as av, type EthereumSign7702AuthorizationInputType as aw, type EthereumRpcInputTypes as ax, type EthereumSignMessageResponseType as ay, type EthereumSecp256k1SignResponseType as az, type AllowlistEntryInput as b, generateAuthorizationSignature as b0, formatRequestForAuthorizationSignature as b1, type AuthTokenClaims as c, type WebhooksVerificationHeaderInput as d, type EmailWithMetadata as e, type PhoneWithMetadata as f, type Wallet as g, type WalletWithMetadata as h, type GoogleOAuthWithMetadata as i, type TwitterOAuthWithMetadata as j, type DiscordOAuthWithMetadata as k, type Github as l, type GithubOAuthWithMetadata as m, type Apple as n, type AppleOAuthWithMetadata as o, type LinkedInOAuthWithMetadata as p, type Tiktok as q, type TiktokOAuthWithMetadata as r, type SpotifyOAuthWithMetadata as s, type Instagram as t, type InstagramOAuthWithMetadata as u, type Telegram as v, type TelegramWithMetadata as w, type FarcasterWithMetadata as x, type CustomJwt as y, type CustomJwtWithMetadata as z };
